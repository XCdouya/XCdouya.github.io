# 上课记录

* Alt+shift+上下键：将光标选中部分上下移动

* Alt+shift+M：将代码块封装成方法

* Alt+shift+t：快速创建方法

* ctrl+r：查找替换

* if尽量使用短路语法，使程序快速回到正轨；

* class.变量 = value;与class.set变量(value);的区别，调用方法能够让程序认知到值的改变，而用 . 来调用的话，程序不能认知到值的改变

* 回答问题时

  * 是什么？
  * 优点，缺点
  * 如果有多个名词，说明他们之间的联系

* 对象创建的过程

   ​                   $ A a =new A();$

   * 第一步：jvm先向内存（堆）中申请一个空间
   * 第二步：为对象的变量赋予初值，如果没有给初始值，那么jvm会为变量提供默认值，int默认值为0；boolean默认值为false，引用类型默认值为NULL
   * 第三步：jvm会调用构造器，执行构造器中的语句
   * 第四步：jvm将开辟出来的空间地址交予栈中某一变量持有

   ``` flow
   st=>start: jvm向内存申请空间
   op=>operation: 为对象的变量赋初始值
   op1=>operation: 调用构造器，执行构造器中的语句
   op2=>operation: 将空间地址返回给栈中变量
   e=>end
   st->op->op1->op2->e->
   & ```

* 封装

   封装可以对类封装也可以对方法封装，

   * 对类封装，将类的两个要素包装到一个单元里
   * 对方法封装，将具有相同功能或相同逻辑的代码块抽取出来，包装成一个方法
   * 说到封装就离不开抽象，抽象就是把一个具体的东西简单化，只留下一个由主要特征构成的概念性事物。
   * 抽象也体现在当我们使用一个类型的实例的时候，在调用其方法时，只需要关注有哪些入参，可以得到什么返回，而无需关注内部的具体实现方式或细节 

* 继承

   * 子类继承父类中除private修饰的成员

   * 子类可以重写父类方法

   * 子类在new的时候是先创建父类对象，再创建子类对象，在创建父类和子类时遵循对象创建的过程

     即：先赋值，再调用构造器，类中的static成员会在jvm加载时就完成创建；所以static优先，父类第二，子类最后

   * java只能单继承，但可以通过多级继承来实现间接的多继承  

* final 修饰词

   * 被final修饰的变量，具有 “ 不可改变 ” 的特性
   * 修饰基本类型：其值不可改变
   * 修饰引用类型：储存的地址不可改变，但地址指向的值可以改变
   * 修饰类：表示这个类为最终版，不可被继承
   * 修饰方法：表示这个方法为最终版，不可被重写
   * final修饰的变量可以在构造器中进行第一次赋值初始化，如果已经初始化赋值过了，那么就不能在构造器中赋值

* static修饰词

   * 由static修饰的成员，不依赖类的实例而存在，一般直接通过类名调用，他是这个类的实例所共有的

   * 被static修饰的成员为静态成员，有且只有一份并在jvm加载过程中就已经生成
   * 当方法被static修饰时，该方法不可以使用非静态成员
   * 当子类重写父类static方法后，具体实现方法根据实例的类型来确定，如下：

   ~~~java
   public class Super{
       static void m1(){
           System.out.println("这是父类静态方法！");
       }
       
       void m2(){
           System.out.println("这是父类普通方法！");
       }
   }
   
   class Child{
       static void m1(){
           System.out.println("这是子类静态方法！");
       }
       
       void m2(){
           System.out.println("这是子类普通方法！");
       }
   }
   
   class test{
       public static void main(String[] args){
           //子类转为父类，向上转型
           Super sup = new Child();
           
           sup.m1();//实例类型为父类，调用父类静态方法
           sup.m2();//new的为子类空间，故调用子类重写后的方法
           
           //父类转为子类，向下转型
           Child child = (Child)sup;
           
           child.m1();//实例类型为子类，调用子类静态方法
           child.m2();//由于地址没发生改变，故实例指向的空间也没变，所以还是调用子类方法
          
       }
   }
   ~~~

   程序运行结果为：

   ![](images/Snipaste_2022-07-15_20-20-56.png)

   

   

   

   

   

   

   

   ## 我的奇思妙想

   

   
